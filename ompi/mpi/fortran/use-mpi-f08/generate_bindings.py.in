# Copyright (c) 2023      Triad National Security, LLC. All rights
#                         reserved.
#
# $COPYRIGHT$
#
# Additional copyrights may follow
#
# $HEADER$
#
"""Fortran binding generation code.

This takes as input a *.in file containing a list of prototypes for Fortran
subroutines with generic types. Using this file, it can generate the Fortran
subroutines in one file and the C wraping code in another for all prototypes
listed.
"""
from abc import ABC, abstractmethod
import argparse
from collections import namedtuple
import re
import sys

FORTRAN_ERROR_NAME = 'ierror'
C_ERROR_NAME = 'ierr'
C_ERROR_TMP_NAME = 'c_ierr'
GENERATED_MESSAGE = 'THIS FILE WAS AUTOMATICALLY GENERATED. DO NOT EDIT BY HAND.'
PROTOTYPE_RE = re.compile(r'^\w+\((\s*\w+\s+\w+\s*(\[\s*\w+\s*=\s*\w+\s*(;\s*\w+\s*=\s*\w+\s*)?\])?\s*,?)+\)$')
# Check if we have support for TS 29113 (templated at configure time)
HAVE_TS = '@OMPI_FORTRAN_HAVE_TS@' == '1'


class FortranType(ABC):

    def __init__(self, name, fn_name, bigcount=False, **kwargs):
        self.name = name
        self.fn_name = fn_name
        self.bigcount = bigcount
        # List of dependent type/parameters, such as for counts
        self.dep_params = None
        self.used_counters = 0

    TYPES = {}

    @classmethod
    def add(cls, type_name):
        """Decorator for adding types."""
        def wrapper(class_):
            cls.TYPES[type_name] = class_
            return class_
        return wrapper

    @classmethod
    def get(cls, type_name):
        return cls.TYPES[type_name]

    @staticmethod
    def validate_dep_param_keys(param_name, keys):
        """Validate the keys that are allowed to be used for a dependent param."""
        # No dependent parameters allowed by default
        if keys:
            raise FortranBindingError(f'Invalid keys found for parameter {param_name}: {list(keys)}')

    @property
    def fn_api_name(self):
        """Return the MPI API name to be used in error messages, etc.."""
        return ext_api_func_name(self.fn_name, bigcount=self.bigcount).upper()

    @property
    def tmp_name(self):
        """Return a temporary name for use in C."""
        return f'c_{self.name}'

    @property
    def tmp_name2(self):
        """Return a secondary temporary name for use in C."""
        return f'c_{self.name}2'

    def tmp_counter(self):
        """Get a temporary counter variable to be used in a loop."""
        name = f'{self.name}_i_{self.used_counters}'
        self.used_counters += 1
        return name

    @abstractmethod
    def declare(self):
        """Return a declaration for the type."""

    def declare_tmp(self):
        """Declare temporaries on in the subroutine."""
        return []

    def declare_cbinding_fortran(self):
        """Return the C binding declaration as seen from Fortran."""
        return self.declare()

    def argument(self):
        """Return the value to pass as an argument."""
        return self.name

    def use(self):
        """Return list of (module, name) for a Fortran use-statement."""
        return []

    def post(self):
        """Return post-processing code to be run after the call."""
        return []

    @abstractmethod
    def c_parameter(self):
        """Return the parameter expression to be used in the C function."""

    def c_declare_tmp(self):
        """Code to declare temporary variables for conversions, etc.."""
        return []

    def c_shortcut_condition(self):
        """Shortcut conditional code.

        If the conditional evaluates to true in C, then code defined in
        c_shortcut_code() for all other parameters will be run and the
        underlying C function will not be called.
        """
        return None

    def c_shortcut_code(self):
        """Shortcut code to run if a parameter defines a shortcut condition."""
        return []

    def c_prepare(self):
        """Code to be called before being passed to underlying C function."""
        return []

    def c_argument(self):
        """Return the value to pass as an argument in the C code."""
        return self.name

    def c_post(self):
        """Code to be run after a call to the underlying C function."""
        return []


class FortranBindingError(Exception):
    """Thrown when a binding error is encountered."""


def validate_allowed_keys(keys, req_keys, type_name, param_name):
    """Validate allowed keys for a type, raising an error on failure."""
    missing_keys = [key for key in req_keys if key not in keys]
    invalid_keys = [key for key in keys if key not in req_keys]
    init_message = f'Param {param_name} with type {type_name}'
    if missing_keys and invalid_keys:
        raise FortranBindingError(f'{init_message} has missing keys ({missing_keys}) and invalid keys ({invalid_keys})')
    elif missing_keys:
        raise FortranBindingError(f'{init_message} has missing keys: {missing_keys}')
    elif invalid_keys:
        raise FortranBindingError(f'{init_message} has invalid keys: {invalid_keys}')


#
# Definitions of generic types in Fortran and how these can be converted
# to and from C.
#

def buffer_tmp_name_ts(basename):
    """Return a temporary name, as used for the buffer CFI code."""
    return f'{basename}_cfi'


@FortranType.add('BUFFER')
class BufferType(FortranType):
    @staticmethod
    def validate_dep_param_keys(param_name, keys):
        validate_allowed_keys(keys, ['count', 'type'], 'BUFFER_OUT', param_name)

    def declare(self):
        return f'@OMPI_F08_IGNORE_TKR_TYPE@, INTENT(IN) :: {self.name}'

    if HAVE_TS:
        def c_parameter(self):
            return f'CFI_cdesc_t *{self.name}'

        @property
        def tmp_datatype1(self):
            return buffer_tmp_name_ts(self.dep_params['type'].name)

        @property
        def tmp_datatype2(self):
            basename = self.dep_params['type'].name
            return buffer_tmp_name_ts(f'{basename}_2')

        @property
        def tmp_count(self):
            return buffer_tmp_name_ts(self.dep_params['count'].name)

        def c_declare_tmp(self):
            type_name = self.dep_params['type'].name
            count_name = self.dep_params['count'].name
            if self.bigcount:
                count_init = f'MPI_Count {self.tmp_count} = *{count_name};'
            else:
                count_init = f'int {self.tmp_count} = OMPI_FINT_2_INT(*{count_name});'
            return [
                f'void *{self.tmp_name} = {self.name}->base_addr;',
                count_init,
                f'MPI_Datatype {self.tmp_datatype1}, {self.tmp_datatype2} = PMPI_Type_f2c(*{type_name});',
            ]

        def c_prepare(self):
            type_name = self.dep_params['type'].name
            return [
                f'OMPI_CFI_2_C({self.name}, {self.tmp_count}, {self.tmp_datatype2}, {self.tmp_datatype1}, {C_ERROR_TMP_NAME});',
                f'if (MPI_SUCCESS != {C_ERROR_TMP_NAME}) {{',
                f'    if (NULL != {C_ERROR_NAME}) *{C_ERROR_NAME} = OMPI_INT_2_FINT({C_ERROR_TMP_NAME});',
                f'    /* TODO: OMPI_ERRHANDLER_INVOKE(c_comm, {C_ERROR_TMP_NAME}, FUNC_NAME); */',
                '    return;',
                '}',
            ]

        def c_argument(self):
            return f'OMPI_F2C_BOTTOM({self.tmp_name})'

        def c_post(self):
            # TODO: Flip names
            return [
                f'if ({self.tmp_datatype1} != {self.tmp_datatype2}) {{',
                f'    ompi_datatype_destroy(&{self.tmp_datatype1});',
                '}',
            ]
    else:
        def c_parameter(self):
            return f'char *{self.name}'

        def c_argument(self):
            return f'OMPI_F2C_BOTTOM({self.name})'


@FortranType.add('BUFFER_ASYNC')
class BufferAsyncType(BufferType):
    def declare(self):
        return f'@OMPI_F08_IGNORE_TKR_TYPE@, INTENT(IN) OMPI_ASYNCHRONOUS :: {self.name}'


@FortranType.add('BUFFER_OUT')
class BufferOutType(BufferType):
    def declare(self):
        return f'@OMPI_F08_IGNORE_TKR_TYPE@ :: {self.name}'


@FortranType.add('BUFFER_ASYNC_OUT')
class BufferAsyncOutType(BufferType):
    def declare(self):
        return f'@OMPI_F08_IGNORE_TKR_TYPE@ OMPI_ASYNCHRONOUS :: {self.name}'


@FortranType.add('COUNT')
class CountType(FortranType):
    def declare(self):
        if self.bigcount:
            return f'INTEGER(KIND=MPI_COUNT_KIND), INTENT(IN) :: {self.name}'
        else:
            return f'INTEGER, INTENT(IN) :: {self.name}'

    def use(self):
        return [('mpi_f08_types', 'MPI_COUNT_KIND')]

    def c_parameter(self):
        type_ = 'MPI_Count' if self.bigcount else 'MPI_Fint'
        return f'{type_} *{self.name}'

    def c_argument(self):
        if HAVE_TS:
            arg = buffer_tmp_name_ts(self.name)
        else:
            arg = f'*{self.name}'
        return arg if self.bigcount else f'OMPI_FINT_2_INT({arg})'


@FortranType.add('DATATYPE')
class DatatypeType(FortranType):
    def declare(self):
        return f'TYPE(MPI_Datatype), INTENT(IN) :: {self.name}'

    def declare_cbinding_fortran(self):
        return f'INTEGER, INTENT(IN) :: {self.name}'

    def argument(self):
        return f'{self.name}%MPI_VAL'

    def use(self):
        return [('mpi_f08_types', 'MPI_Datatype')]

    def c_parameter(self):
        return f'MPI_Fint *{self.name}'

    if HAVE_TS:
        def c_prepare(self):
            # Preparation code is done by the BUFFER type
            return []

        def c_argument(self):
            return buffer_tmp_name_ts(self.name)
    else:
        def c_prepare(self):
            return [f'MPI_Datatype {self.tmp_name} = PMPI_Type_f2c(*{self.name});']

        def c_argument(self):
            return self.tmp_name


@FortranType.add('INT')
class IntType(FortranType):
    def declare(self):
        return f'INTEGER, INTENT(IN) :: {self.name}'

    def c_parameter(self):
        return f'MPI_Fint *{self.name}'

    def c_argument(self):
        return f'OMPI_FINT_2_INT(*{self.name})'


@FortranType.add('RANK')
class RankType(IntType):
    pass


@FortranType.add('TAG')
class TagType(IntType):
    pass


@FortranType.add('INDEX_OUT')
class IndexOutType(IntType):
    def declare(self):
        return f'INTEGER, INTENT(OUT) :: {self.name}'

    def c_declare_tmp(self):
        return [f'int {self.tmp_name};']

    def c_shortcut_code(self):
        return [f'*{self.name} = OMPI_INT_2_FINT(MPI_UNDEFINED);']

    def c_argument(self):
        return f'&{self.tmp_name}'

    def c_post(self):
        return [
            f'if (MPI_SUCCESS == {C_ERROR_TMP_NAME} && MPI_UNDEFINED != {self.tmp_name}) {{',
            f'    {self.tmp_name} += 1;'
            f'    *{self.name} = OMPI_INT_2_FINT({self.tmp_name});'
            '}',
        ]


@FortranType.add('LOGICAL_OUT')
class LogicalOutType(IntType):
    """Logical type.

    NOTE: Since the logical type causes difficulties when passed to C code,
    this code uses a temporary integer in Fortran to pass to the C code. On
    completion the logical type is set based on C's true/false rules.
    """

    def declare(self):
        return f'LOGICAL, INTENT(OUT) :: {self.name}'

    def declare_tmp(self):
        return [f'INTEGER :: {self.tmp_name} = 0']

    def declare_cbinding_fortran(self):
        return f'INTEGER, INTENT(OUT) :: {self.name}'

    def argument(self):
        return self.tmp_name

    def post(self):
        return [f'{self.name} = {self.tmp_name} /= 0']

    def c_parameter(self):
        return f'MPI_Fint *{self.name}'

    def c_declare_tmp(self):
        return [f'int {self.tmp_name};']

    def c_shortcut_code(self):
        return [f'*{self.name} = OMPI_INT_2_FINT(1);']

    def c_argument(self):
        return f'&{self.tmp_name}'

    def c_post(self):
        return [f'*{self.name} = OMPI_INT_2_FINT({self.tmp_name});']


@FortranType.add('COMM')
class CommType(FortranType):
    def declare(self):
        return f'TYPE(MPI_Comm), INTENT(IN) :: {self.name}'

    def declare_cbinding_fortran(self):
        return f'INTEGER, INTENT(IN) :: {self.name}'

    def argument(self):
        return f'{self.name}%MPI_VAL'

    def use(self):
        return [('mpi_f08_types', 'MPI_Comm')]

    def c_parameter(self):
        return f'MPI_Fint *{self.name}'

    def c_prepare(self):
        return [f'MPI_Comm {self.tmp_name} = PMPI_Comm_f2c(*{self.name});']

    def c_argument(self):
        return self.tmp_name


@FortranType.add('STATUS')
class StatusType(FortranType):
    def declare(self):
        return f'TYPE(MPI_Status), INTENT(OUT) :: {self.name}'

    def use(self):
        return [('mpi_f08_types', 'MPI_Status')]

    def c_parameter(self):
        # TODO: Is this correct? (I've listed it as TYPE(MPI_Status) in the binding)
        return f'MPI_Fint *{self.name}'

    def c_shortcut_code(self):
        return [f'PMPI_Status_c2f(&ompi_status_empty, {self.name});']

    # TODO: This code should be in c_declare_tmp()
    def c_prepare(self):
        return [
            f'OMPI_FORTRAN_STATUS_DECLARATION({self.tmp_name}, {self.tmp_name2});',
            f'OMPI_FORTRAN_STATUS_SET_POINTER({self.tmp_name}, {self.tmp_name2}, {self.name});'
        ]

    def c_argument(self):
        return self.tmp_name

    def c_post(self):
        return [f'OMPI_FORTRAN_STATUS_RETURN({self.tmp_name}, {self.tmp_name2}, {self.name}, {C_ERROR_TMP_NAME});']


@FortranType.add('SHORTCUT_COUNT')
class ShortcutCountType(FortranType):
    """Shortcut count type.

    This type is an integer that, when 0, can be used to shortcut a call to the
    underyling C binding. Other types may implement a `c_shortcut` method that
    will return code to execute upon a shortcut operation.

    The shortcut conditional is placed right after c temporary declarations but
    before the c prepare code.
    """

    def declare(self):
        return f'INTEGER, INTENT(IN) :: {self.name}'

    def c_parameter(self):
        return f'MPI_Fint *{self.name}'

    def c_shortcut_condition(self):
        return f'OPAL_UNLIKELY(0 == OMPI_FINT_2_INT(*{self.name}))'

    def c_argument(self):
        return f'OMPI_FINT_2_INT(*{self.name})'


@FortranType.add('REQUEST')
class RequestType(FortranType):
    def declare(self):
        return f'TYPE(MPI_Request), INTENT(OUT) :: {self.name}'

    def declare_cbinding_fortran(self):
        return f'INTEGER, INTENT(OUT) :: {self.name}'

    def argument(self):
        return f'{self.name}%MPI_VAL'

    def use(self):
        return [('mpi_f08_types', 'MPI_Request')]

    def c_parameter(self):
        return f'MPI_Fint *{self.name}'

    def c_declare_tmp(self):
        return [f'MPI_Request {self.tmp_name};']

    def c_argument(self):
        return f'&{self.tmp_name}'

    def c_post(self):
        return [
            f'if (MPI_SUCCESS == {C_ERROR_TMP_NAME}) {{',
            f'    *{self.name} = PMPI_Request_c2f({self.tmp_name});',
            '}',
        ]


def allocate_array(name, malloc_expr, fn_api_name):
    """Generate code for allocating an array and checking the result."""
    return [
        f'{name} = malloc({malloc_expr});',
        f'if (NULL == {name}) {{',
        f'    {C_ERROR_TMP_NAME} = OMPI_ERRHANDLER_NOHANDLE_INVOKE(MPI_ERR_NO_MEM, "{fn_api_name}");',
        f'    *{C_ERROR_NAME} = OMPI_INT_2_FINT({C_ERROR_TMP_NAME});',
        '    return;',
        '}',
    ]


@FortranType.add('REQUEST_ARRAY')
class RequestArrayType(FortranType):
    @staticmethod
    def validate_dep_param_keys(param_name, keys):
        validate_allowed_keys(keys, ['count'], 'REQUEST_ARRAY', param_name)

    def declare(self):
        return f'TYPE(MPI_Request), INTENT(INOUT) :: {self.name}({self.dep_params["count"].name})'

    def declare_cbinding_fortran(self):
        return f'INTEGER, INTENT(INOUT) :: {self.name}({self.dep_params["count"].name})'

    def argument(self):
        return f'{self.name}(:)%MPI_VAL'

    def use(self):
        return [('mpi_f08_types', 'MPI_Request')]

    def c_parameter(self):
        return f'MPI_Fint *{self.name}'

    def c_declare_tmp(self):
        return [f'MPI_Request *{self.tmp_name};']

    def c_prepare(self):
        tmp_name = self.tmp_name
        code = allocate_array(tmp_name,
                              f'{self.dep_params["count"].c_argument()} * sizeof(MPI_Request)',
                              self.fn_api_name)
        i = self.tmp_counter()
        code.extend([
            f'for (int {i} = 0; {i} < {self.dep_params["count"].c_argument()}; ++{i}) {{',
            f'    {tmp_name}[{i}] = PMPI_Request_f2c({self.name}[{i}]);',
            '}',
        ])
        return code

    def c_argument(self):
        return self.tmp_name

    def c_post(self):
        i = self.tmp_counter()
        return [
            f'if (MPI_SUCCESS == {C_ERROR_TMP_NAME}) {{',
            f'    for (int {i} = 0; {i} < {self.dep_params["count"].c_argument()}; ++{i}) {{',
            f'        {self.name}[{i}] = {self.tmp_name}[{i}]->req_f_to_c_index;',
            '    }',
            '}',
            f'free({self.tmp_name});',
        ]


@FortranType.add('STATUS_ARRAY')
class StatusArrayType(FortranType):
    @staticmethod
    def validate_dep_param_keys(param_name, keys):
        validate_allowed_keys(keys, ['count'], 'STATUS_ARRAY', param_name)

    def declare(self):
        return f'TYPE(MPI_Status), INTENT(OUT) :: {self.name}(*)'

    def use(self):
        return [('mpi_f08_types', 'MPI_Status')]

    def c_parameter(self):
        return f'MPI_Fint *{self.name}'

    def c_declare_tmp(self):
        return [f'MPI_Status *{self.tmp_name};']

    def c_prepare(self):
        return allocate_array(self.tmp_name,
                              f'{self.dep_params["count"].c_argument()} * sizeof(MPI_Status)',
                              self.fn_api_name)

    def c_argument(self):
        return self.tmp_name

    def c_post(self):
        i = self.tmp_counter()
        return [
            f'if (MPI_SUCCESS == {C_ERROR_TMP_NAME}) {{',
            f'    for (int {i} = 0; {i} < {self.dep_params["count"].c_argument()}; ++{i}) {{',
            f'        if (!OMPI_IS_FORTRAN_STATUSES_IGNORE({self.name}) &&',
            f'            !OMPI_IS_FORTRAN_STATUS_IGNORE(&{self.name}[{i}])) {{',
            f'            PMPI_Status_c2f(&{self.tmp_name}[{i}], &{self.name}[{i} * (sizeof(MPI_Status) / sizeof(int))]);',
            '        }',
            '    }',
            '}',
            f'free({self.tmp_name});'
        ]


def ext_api_func_name(fn_name, bigcount=False):
    """Produce the external MPI API function name."""
    suffix = '_c' if bigcount else ''
    return f'MPI_{fn_name.capitalize()}{suffix}'


def ext_api_func_name_profile(fn_name, bigcount=False):
    """Produce the external PMPI API function name."""
    return f'P{ext_api_func_name(fn_name, bigcount)}'


def fortran_f08_name(fn_name, bigcount=False):
    """Produce the final f08 name from base_name."""
    suffix = '_c' if bigcount else ''
    return f'MPI_{fn_name.capitalize()}_f08{suffix}'


FortranParameter = namedtuple('FortranParameter', ['type_name', 'name', 'dep_params'])
FortranPrototype = namedtuple('FortranPrototype', ['fn_name', 'lno', 'parameters'])


def load_prototypes(fname):
    """Load the prototypes from a file."""
    with open(fname) as fp:
        prototypes = []

        for i, line in enumerate(fp):
            lno = i + 1
            line = line.strip()
            if line and line[0] == '#':
                continue
            if PROTOTYPE_RE.match(line) is None:
                raise FortranBindingError(
                    f'Invalid function prototype for Fortran interface on line {lno}'
                )

            start = line.index('(')
            end = line.index(')')
            fn_name = line[:start].strip()
            parameters = line[start+1:end].split(',')

            # Attempt to parse each parameter
            parsed_parameters = []
            try:
                for param in parameters:
                    param = param.strip()
                    param_parts = param.split()
                    type_name = param_parts[0]
                    name = ''.join(param_parts[1:])
                    type_ = FortranType.get(type_name)
                    dep_params = None
                    # Check for 'param[name=param(;name=param)]' parameters,
                    # indicating a dependency on that other parameter
                    if '[' in name:
                        idx = name.index('[')
                        dep_params = [part.split('=') for part in name[idx+1:-1].split(';')]
                        dep_params = dict(dep_params)
                        name = name[:idx]
                        # Validate the parameter key values
                        type_.validate_dep_param_keys(name, dep_params.keys())
                    parsed_parameters.append(FortranParameter(type_name, name, dep_params))
                prototypes.append(FortranPrototype(fn_name, lno, parsed_parameters))
            except FortranBindingError as err:
                raise FortranBindingError(
                    f'Failed to parse prototype on line {lno}: {err}'
                ) from None

        return prototypes


class FortranBinding:
    """Class for generating the binding for a single function."""

    def __init__(self, prototype, bigcount=False):
        self.bigcount = bigcount
        self.fn_name = prototype.fn_name
        self.parameters = []
        param_map = {}
        dep_params = {}
        for param in prototype.parameters:
            type_ = FortranType.get(param.type_name)
            param_type = type_(param.name, self.fn_name, bigcount=bigcount)
            self.parameters.append(param_type)
            param_map[param.name] = param_type
            if param.dep_params is not None:
                dep_params[param.name] = param.dep_params
        # Set dependent parameters for those that need them
        try:
            for name, deps in dep_params.items():
                param_map[name].dep_params = {key: param_map[dep_name] for key, dep_name in deps.items()}
        except KeyError as err:
            raise FortranBindingError(f'Invalid dependent type listed on line {prototype.lno}: {err}')

    def _fn_name_suffix(self):
        """Return a suffix for function names."""
        return '_c' if self.bigcount else ''

    @property
    def c_func_name(self):
        """Produce the final C func name from base_name."""
        return f'ompi_{self.fn_name}_wrapper_f08{self._fn_name_suffix()}'

    def _param_list(self):
        return ','.join(type_.name for type_ in self.parameters)

    def _use(self):
        """Determine the Fortran use-statements needed."""
        use = {}
        for param in self.parameters:
            for mod, name in param.use():
                if mod not in use:
                    use[mod] = set()
                use[mod].add(name)
        return use

    def _use_stmts(self):
        """Return a list of required use statments."""
        use = self._use()
        stmts = []
        for mod, names in use.items():
            names = ', '.join(names)
            stmts.append(f'use :: {mod}, only: {names}')
        return stmts

    def _print_fortran_interface(self):
        """Output the C subroutine binding for the Fortran code."""
        name = self.c_func_name
        print('    interface')
        print(f'        subroutine {name}({self._param_list()},{FORTRAN_ERROR_NAME}) &')
        print(f'            BIND(C, name="{name}")')
        use_stmts = self._use_stmts()
        for stmt in use_stmts:
            print(f'            {stmt}')
        print('            implicit none')
        for param in self.parameters:
            print(f'            {param.declare_cbinding_fortran()}')
        print(f'            INTEGER, INTENT(OUT) :: {FORTRAN_ERROR_NAME}')
        print(f'        end subroutine {name}')
        print('    end interface')

    def _print_fortran_header(self):
        """Print the header, including use stmts, dummy variable decls, etc..

        This does not include the subroutine line.
        """
        # Use statements
        use_stmts = self._use_stmts()
        for stmt in use_stmts:
            print(f'    {stmt}')
        print('    implicit none')
        # Parameters/dummy variable declarations
        types = []
        for param in self.parameters:
            print(f'    {param.declare()}')
        # Add the integer error manually
        print(f'    INTEGER, OPTIONAL, INTENT(OUT) :: {FORTRAN_ERROR_NAME}')

    def _print_fortran_subroutine(self):
        """Output the Fortran subroutine line."""
        sub_name = fortran_f08_name(self.fn_name, bigcount=self.bigcount)
        print('subroutine', f'{sub_name}({self._param_list()},{FORTRAN_ERROR_NAME})')

    def _print_fortran_subroutine_end(self):
        """Output the Fortran end subroutine line."""
        sub_name = fortran_f08_name(self.fn_name, bigcount=self.bigcount)
        print(f'end subroutine {sub_name}')

    def print_f_source(self):
        """Output the main MPI Fortran subroutine."""
        self._print_fortran_subroutine()
        self._print_fortran_header()

        # Temporaries
        print(f'    INTEGER :: {C_ERROR_TMP_NAME}')
        for param in self.parameters:
            for line in param.declare_tmp():
                print(f'    {line}')

        # Interface for call to C function
        print()
        self._print_fortran_interface()
        print()

        # Call into the C function
        args = ','.join(param.argument() for param in self.parameters)
        print(f'    call {self.c_func_name}({args},{C_ERROR_TMP_NAME})')
        # Convert error type
        print(f'    if (present({FORTRAN_ERROR_NAME})) {FORTRAN_ERROR_NAME} = {C_ERROR_TMP_NAME}')

        for param in self.parameters:
            for line in param.post():
                print(f'    {line}')

        self._print_fortran_subroutine_end()

    def print_c_source(self):
        """Output the C source and function that the Fortran calls into."""
        parameters = [param.c_parameter() for param in self.parameters]
        # Always append the integer error
        parameters.append(f'MPI_Fint *{C_ERROR_NAME}')
        parameters = ', '.join(parameters)
        # Just put the signature here to silence `-Wmissing-prototypes`
        c_func = self.c_func_name
        print(f'void {c_func}({parameters});')
        print(f'void {c_func}({parameters})')
        print('{')
        print(f'    int {C_ERROR_TMP_NAME}; ')

        # First the temporary declarations
        for param in self.parameters:
            for line in param.c_declare_tmp():
                print(f'    {line}')

        # Shortcut conditions, if any
        for param in self.parameters:
            condition = param.c_shortcut_condition()
            if condition is None:
                continue
            print(f'    if ({condition}) {{')
            print(f'        *{C_ERROR_NAME} = OMPI_INT_2_FINT(MPI_SUCCESS);')
            for other_param in self.parameters:
                for line in other_param.c_shortcut_code():
                    print(f'        {line}')
            print('        return;')
            print('    }')

        # Prepare code for temporaries, etc.
        for param in self.parameters:
            for line in param.c_prepare():
                print(f'    {line}')

        # Call into the C API
        c_api_func = ext_api_func_name_profile(self.fn_name, bigcount=self.bigcount)
        arguments = [param.c_argument() for param in self.parameters]
        arguments = ', '.join(arguments)
        print(f'    {C_ERROR_TMP_NAME} = {c_api_func}({arguments});')

        # Post-processing code
        print(f'    *{C_ERROR_NAME} = OMPI_INT_2_FINT({C_ERROR_TMP_NAME});')
        for param in self.parameters:
            for line in param.c_post():
                print(f'    {line}')
        print('}')

    def print_interface(self):
        """Output just the Fortran interface for this binding."""
        self._print_fortran_subroutine()
        self._print_fortran_header()
        self._print_fortran_subroutine_end()


def print_f_source_header():
    """Print the fortran f08 file header."""
    print(f'! {GENERATED_MESSAGE}')
    print('#include "ompi/mpi/fortran/configure-fortran-output.h"')


def print_profiling_rename_macros(prototypes):
    """Print macros for renaming functions for the profiling interface.

    Previously hardcoded in mpi-f08-rename.h.
    """
    print('#if OMPI_BUILD_MPI_PROFILING')
    for prototype in prototypes:
        name = fortran_f08_name(prototype.fn_name)
        print(f'#define {name} P{name}')
        # Check for bigcount version
        if prototype_has_bigcount(prototype):
            bigcount_name = fortran_f08_name(prototype.fn_name, bigcount=True)
            print(f'#define {bigcount_name} P{bigcount_name}')
    print('#endif /* OMPI_BUILD_MPI_PROFILING */')


def print_c_source_header():
    """Print the header of the C source file."""
    print(f'/* {GENERATED_MESSAGE} */')
    if HAVE_TS:
        print('#include <ISO_Fortran_binding.h>')
        print('#include "ts.h"')
    print('#include "ompi_config.h"')
    print('#include "mpi.h"')
    print('#include "ompi/errhandler/errhandler.h"')
    print('#include "ompi/mpi/fortran/mpif-h/status-conversion.h"')
    print('#include "ompi/mpi/fortran/base/constants.h"')
    print('#include "ompi/mpi/fortran/base/fint_2_int.h"')
    print('#include "ompi/request/request.h"')


def print_binding(prototype, lang, bigcount=False):
    """Print the binding with or without bigcount."""
    binding = FortranBinding(prototype, bigcount=bigcount)
    if lang == 'fortran':
        binding.print_f_source()
    else:
        binding.print_c_source()


def prototype_has_bigcount(prototype):
    """Should this prototype have a bigcount version?"""
    return any(param.type_name == 'COUNT' for param in prototype.parameters)


def generate_code(args, prototypes):
    """Generate binding code based on arguments."""
    if args.lang == 'fortran':
        print_f_source_header()
        print()
        print_profiling_rename_macros(prototypes)
        print()
    else:
        print_c_source_header()
    for prototype in prototypes:
        print()
        print_binding(prototype, args.lang)
        if prototype_has_bigcount(prototype):
            print()
            print_binding(prototype, args.lang, bigcount=True)


def generate_interface(args, prototypes):
    """Generate the Fortran interface files."""
    print(f'! {GENERATED_MESSAGE}')
    for prototype in prototypes:
        ext_name = ext_api_func_name(prototype.fn_name)
        print(f'interface {ext_name}')
        binding = FortranBinding(prototype)
        binding.print_interface()
        if prototype_has_bigcount(prototype):
            print()
            binding_c = FortranBinding(prototype, bigcount=True)
            binding_c.print_interface()
        print(f'end interface {ext_name}')


def main():
    parser = argparse.ArgumentParser(description='generate fortran binding files')
    parser.add_argument('--template', required=True, help='template file to use')
    subparsers = parser.add_subparsers(required=True)

    # Handler for generating actual code
    parser_code = subparsers.add_parser('code', help='generate binding code')
    parser_code.add_argument('lang', choices=('fortran', 'c'),
                             help='generate dependent files in C or Fortran')
    parser_code.set_defaults(handler=generate_code)

    # Handler for generating the Fortran interface files
    parser_interface = subparsers.add_parser('interface',
                                             help='generate Fortran interface specifcations')
    parser_interface.set_defaults(handler=generate_interface)

    args = parser.parse_args()

    prototypes = load_prototypes(args.template)
    args.handler(args, prototypes)


if __name__ == '__main__':
    main()
